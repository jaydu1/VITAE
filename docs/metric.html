<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>VITAE.metric API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>VITAE.metric</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import networkx as nx
import networkx.algorithms.isomorphism as iso
import numpy as np
import pandas as pd
from scipy.sparse.csgraph import laplacian
from scipy.linalg import eigh
from scipy.integrate import quad
from sklearn.metrics import pairwise_distances
import warnings

import numba
from numba import jit, float32


def topology(G_true, G_pred):
    &#39;&#39;&#39;Evaulate topology metrics.

    Parameters
    ----------
    G_true : nx.Graph
        The reference graph.
    G_pred : nx.Graph
        The estimated graph.
    
    Returns
    ----------
    res : dict
        a dict containing evaulation results.
    &#39;&#39;&#39;     
    res = {}
    
    # 1. Isomorphism with same initial node
    def comparison(N1, N2):
        if N1[&#39;is_init&#39;] != N2[&#39;is_init&#39;]:
            return False
        else:
            return True
    score_isomorphism = int(nx.is_isomorphic(G_true, G_pred, node_match=comparison))
    res[&#39;ISO score&#39;] = score_isomorphism
    
    # 2. GED (graph edit distance)
    if len(G_true)&gt;10:
        warnings.warn(&#34;Didn&#39;t calculate graph edit distances for large graphs.&#34;)
        res[&#39;GED score&#39;] = np.nan  
    else:
        max_num_oper = len(G_true)
        GED = nx.graph_edit_distance(G_pred, G_true, 
                                node_match=comparison,
                                upper_bound=max_num_oper)
        if GED is None:
            res[&#39;GED score&#39;] = 0
        else:            
            score_GED = 1 - GED / max_num_oper
            res[&#39;GED score&#39;] = score_GED
        
    # 3. Ipsen-Mikhailov distance
    if len(G_true)==len(G_pred):
        score_IM = 1 - IM_dist(G_true, G_pred)
        score_IM = np.maximum(0, score_IM)
    else:
        score_IM = 0
    res[&#39;IM score&#39;] = score_IM
    return res


def IM_dist(G1, G2):
    &#39;&#39;&#39;The Ipsen-Mikailov distance is a global (spectral) metric, 
    corresponding to the square-root of the squared difference of the
    Laplacian spectrum for each graph.

    Implementation adapt from
    https://netrd.readthedocs.io/en/latest/_modules/netrd/distance/hamming_ipsen_mikhailov.html

    Parameters
    ----------
    G1 : nx.Graph
    G2 : nx.Graph

    Returns
    ----------
    IM(G1,G2) : float
        The IM distance between G1 and G2.
    &#39;&#39;&#39;
    adj1 = nx.to_numpy_array(G1)
    adj2 = nx.to_numpy_array(G2)
    hwhm = 0.08
    
    N = len(adj1)
    # get laplacian matrix
    L1 = laplacian(adj1, normed=False)
    L2 = laplacian(adj2, normed=False)

    # get the modes for the positive-semidefinite laplacian
    w1 = np.sqrt(np.abs(eigh(L1)[0][1:]))
    w2 = np.sqrt(np.abs(eigh(L2)[0][1:]))

    # we calculate the norm for both spectrum
    norm1 = (N - 1) * np.pi / 2 - np.sum(np.arctan(-w1 / hwhm))
    norm2 = (N - 1) * np.pi / 2 - np.sum(np.arctan(-w2 / hwhm))

    # define both spectral densities
    density1 = lambda w: np.sum(hwhm / ((w - w1) ** 2 + hwhm ** 2)) / norm1
    density2 = lambda w: np.sum(hwhm / ((w - w2) ** 2 + hwhm ** 2)) / norm2

    func = lambda w: (density1(w) - density2(w)) ** 2
    return np.sqrt(quad(func, 0, np.inf, limit=100)[0])


@jit((float32[:,:], float32[:,:]), nopython=True, nogil=True)
def _rand_index(true, pred):
    n = true.shape[0]
    m_true = true.shape[1]
    m_pred = pred.shape[1]
    RI = 0.0
    for i in range(1, n-1):
        for j in range(i, n):
            RI_ij = 0.0
            for k in range(m_true):
                RI_ij += true[i,k]*true[j,k]
            for k in range(m_pred):
                RI_ij -= pred[i,k]*pred[j,k]
            RI += 1-np.abs(RI_ij)
    return RI / (n*(n-1)/2.0)


def get_GRI(true, pred):
    &#39;&#39;&#39;Compute the GRI.

    Parameters
    ----------
    ture : np.array
        [n_samples, n_cluster_1] for proportions or [n_samples, ] for grouping
    pred : np.array
        [n_samples, n_cluster_2] for estimated proportions or [n_samples, ] for grouping

    Returns
    ----------
    GRI : float
        The GRI of two groups of proportions in the trajectories.
    &#39;&#39;&#39;
    if len(true)!=len(pred):
        raise ValueError(&#39;Inputs should have same lengths!&#39;)
        
    if len(true.shape)==1:
        true = pd.get_dummies(true).values
    if len(pred.shape)==1:
        pred = pd.get_dummies(pred).values
    
    true = np.sqrt(true).astype(np.float32)
    pred = np.sqrt(pred).astype(np.float32)

    return _rand_index(true, pred)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="VITAE.metric.topology"><code class="name flex">
<span>def <span class="ident">topology</span></span>(<span>G_true, G_pred)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaulate topology metrics.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G_true</code></strong> :&ensp;<code>nx.Graph</code></dt>
<dd>The reference graph.</dd>
<dt><strong><code>G_pred</code></strong> :&ensp;<code>nx.Graph</code></dt>
<dd>The estimated graph.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>res</code></strong> :&ensp;<code>dict</code></dt>
<dd>a dict containing evaulation results.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def topology(G_true, G_pred):
    &#39;&#39;&#39;Evaulate topology metrics.

    Parameters
    ----------
    G_true : nx.Graph
        The reference graph.
    G_pred : nx.Graph
        The estimated graph.
    
    Returns
    ----------
    res : dict
        a dict containing evaulation results.
    &#39;&#39;&#39;     
    res = {}
    
    # 1. Isomorphism with same initial node
    def comparison(N1, N2):
        if N1[&#39;is_init&#39;] != N2[&#39;is_init&#39;]:
            return False
        else:
            return True
    score_isomorphism = int(nx.is_isomorphic(G_true, G_pred, node_match=comparison))
    res[&#39;ISO score&#39;] = score_isomorphism
    
    # 2. GED (graph edit distance)
    if len(G_true)&gt;10:
        warnings.warn(&#34;Didn&#39;t calculate graph edit distances for large graphs.&#34;)
        res[&#39;GED score&#39;] = np.nan  
    else:
        max_num_oper = len(G_true)
        GED = nx.graph_edit_distance(G_pred, G_true, 
                                node_match=comparison,
                                upper_bound=max_num_oper)
        if GED is None:
            res[&#39;GED score&#39;] = 0
        else:            
            score_GED = 1 - GED / max_num_oper
            res[&#39;GED score&#39;] = score_GED
        
    # 3. Ipsen-Mikhailov distance
    if len(G_true)==len(G_pred):
        score_IM = 1 - IM_dist(G_true, G_pred)
        score_IM = np.maximum(0, score_IM)
    else:
        score_IM = 0
    res[&#39;IM score&#39;] = score_IM
    return res</code></pre>
</details>
</dd>
<dt id="VITAE.metric.IM_dist"><code class="name flex">
<span>def <span class="ident">IM_dist</span></span>(<span>G1, G2)</span>
</code></dt>
<dd>
<div class="desc"><p>The Ipsen-Mikailov distance is a global (spectral) metric,
corresponding to the square-root of the squared difference of the
Laplacian spectrum for each graph.</p>
<p>Implementation adapt from
<a href="https://netrd.readthedocs.io/en/latest/_modules/netrd/distance/hamming_ipsen_mikhailov.html">https://netrd.readthedocs.io/en/latest/_modules/netrd/distance/hamming_ipsen_mikhailov.html</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G1</code></strong> :&ensp;<code>nx.Graph</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>G2</code></strong> :&ensp;<code>nx.Graph</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>IM(G1,G2) : float</code></dt>
<dd>The IM distance between G1 and G2.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IM_dist(G1, G2):
    &#39;&#39;&#39;The Ipsen-Mikailov distance is a global (spectral) metric, 
    corresponding to the square-root of the squared difference of the
    Laplacian spectrum for each graph.

    Implementation adapt from
    https://netrd.readthedocs.io/en/latest/_modules/netrd/distance/hamming_ipsen_mikhailov.html

    Parameters
    ----------
    G1 : nx.Graph
    G2 : nx.Graph

    Returns
    ----------
    IM(G1,G2) : float
        The IM distance between G1 and G2.
    &#39;&#39;&#39;
    adj1 = nx.to_numpy_array(G1)
    adj2 = nx.to_numpy_array(G2)
    hwhm = 0.08
    
    N = len(adj1)
    # get laplacian matrix
    L1 = laplacian(adj1, normed=False)
    L2 = laplacian(adj2, normed=False)

    # get the modes for the positive-semidefinite laplacian
    w1 = np.sqrt(np.abs(eigh(L1)[0][1:]))
    w2 = np.sqrt(np.abs(eigh(L2)[0][1:]))

    # we calculate the norm for both spectrum
    norm1 = (N - 1) * np.pi / 2 - np.sum(np.arctan(-w1 / hwhm))
    norm2 = (N - 1) * np.pi / 2 - np.sum(np.arctan(-w2 / hwhm))

    # define both spectral densities
    density1 = lambda w: np.sum(hwhm / ((w - w1) ** 2 + hwhm ** 2)) / norm1
    density2 = lambda w: np.sum(hwhm / ((w - w2) ** 2 + hwhm ** 2)) / norm2

    func = lambda w: (density1(w) - density2(w)) ** 2
    return np.sqrt(quad(func, 0, np.inf, limit=100)[0])</code></pre>
</details>
</dd>
<dt id="VITAE.metric.get_GRI"><code class="name flex">
<span>def <span class="ident">get_GRI</span></span>(<span>true, pred)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the GRI.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ture</code></strong> :&ensp;<code>np.array</code></dt>
<dd>[n_samples, n_cluster_1] for proportions or [n_samples, ] for grouping</dd>
<dt><strong><code>pred</code></strong> :&ensp;<code>np.array</code></dt>
<dd>[n_samples, n_cluster_2] for estimated proportions or [n_samples, ] for grouping</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>GRI</code></strong> :&ensp;<code>float</code></dt>
<dd>The GRI of two groups of proportions in the trajectories.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_GRI(true, pred):
    &#39;&#39;&#39;Compute the GRI.

    Parameters
    ----------
    ture : np.array
        [n_samples, n_cluster_1] for proportions or [n_samples, ] for grouping
    pred : np.array
        [n_samples, n_cluster_2] for estimated proportions or [n_samples, ] for grouping

    Returns
    ----------
    GRI : float
        The GRI of two groups of proportions in the trajectories.
    &#39;&#39;&#39;
    if len(true)!=len(pred):
        raise ValueError(&#39;Inputs should have same lengths!&#39;)
        
    if len(true.shape)==1:
        true = pd.get_dummies(true).values
    if len(pred.shape)==1:
        pred = pd.get_dummies(pred).values
    
    true = np.sqrt(true).astype(np.float32)
    pred = np.sqrt(pred).astype(np.float32)

    return _rand_index(true, pred)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="VITAE" href="index.html">VITAE</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="VITAE.metric.topology" href="#VITAE.metric.topology">topology</a></code></li>
<li><code><a title="VITAE.metric.IM_dist" href="#VITAE.metric.IM_dist">IM_dist</a></code></li>
<li><code><a title="VITAE.metric.get_GRI" href="#VITAE.metric.get_GRI">get_GRI</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>